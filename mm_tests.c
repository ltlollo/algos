// This is free and unencumbered software released into the public domain.
// For more information, see LICENSE

#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "mm.h"

#define TEST(x) {x, ""#x }
#define L3 (2048 * 1024)
#define L2 ( 256 * 1024)

float A[L2 / sizeof (float)];
float B[L3 / sizeof (float)];

int
test_8x16x8(void) {
    size_t m, k, n;
    m = n = 8;
    k = 16;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        12800,  28160,  43520,  58880,  74240,  89600,  104960, 120320,
        12968,  28584,  44200,  59816,  75432,  91048,  106664, 122280,
        13136,  29008,  44880,  60752,  76624,  92496,  108368, 124240,
        13304,  29432,  45560,  61688,  77816,  93944,  110072, 126200,
        13472,  29856,  46240,  62624,  79008,  95392,  111776, 128160,
        13640,  30280,  46920,  63560,  80200,  96840,  113480, 130120,
        13808,  30704,  47600,  64496,  81392,  98288,  115184, 132080,
        13976,  31128,  48280,  65432,  82584,  99736,  116888, 134040,
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_16x8x8(void) {
    size_t m, k, n;
    m = 16;
    n = k = 8;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        3584,   7168,   10752,  14336,  17920,  21504,  25088,  28672,
        3636,   7284,   10932,  14580,  18228,  21876,  25524,  29172,
        3688,   7400,   11112,  14824,  18536,  22248,  25960,  29672,
        3740,   7516,   11292,  15068,  18844,  22620,  26396,  30172,
        3792,   7632,   11472,  15312,  19152,  22992,  26832,  30672,
        3844,   7748,   11652,  15556,  19460,  23364,  27268,  31172,
        3896,   7864,   11832,  15800,  19768,  23736,  27704,  31672,
        3948,   7980,   12012,  16044,  20076,  24108,  28140,  32172,
        4000,   8096,   12192,  16288,  20384,  24480,  28576,  32672,
        4052,   8212,   12372,  16532,  20692,  24852,  29012,  33172,
        4104,   8328,   12552,  16776,  21000,  25224,  29448,  33672,
        4156,   8444,   12732,  17020,  21308,  25596,  29884,  34172,
        4208,   8560,   12912,  17264,  21616,  25968,  30320,  34672,
        4260,   8676,   13092,  17508,  21924,  26340,  30756,  35172,
        4312,   8792,   13272,  17752,  22232,  26712,  31192,  35672,
        4364,   8908,   13452,  17996,  22540,  27084,  31628,  36172,
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_8x8x16(void) {
    size_t m, k, n;
    n = 16;
    m = k = 8;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        1792,   3584,   5376,   7168,   8960,   10752,  12544,  14336,  16128,  17920,  19712,  21504,23296,   25088,  26880,  28672,
        1844,   3700,   5556,   7412,   9268,   11124,  12980,  14836,  16692,  18548,  20404,  22260,24116,   25972,  27828,  29684,
        1896,   3816,   5736,   7656,   9576,   11496,  13416,  15336,  17256,  19176,  21096,  23016,24936,   26856,  28776,  30696,
        1948,   3932,   5916,   7900,   9884,   11868,  13852,  15836,  17820,  19804,  21788,  23772,25756,   27740,  29724,  31708,
        2000,   4048,   6096,   8144,   10192,  12240,  14288,  16336,  18384,  20432,  22480,  24528,26576,   28624,  30672,  32720,
        2052,   4164,   6276,   8388,   10500,  12612,  14724,  16836,  18948,  21060,  23172,  25284,27396,   29508,  31620,  33732,
        2104,   4280,   6456,   8632,   10808,  12984,  15160,  17336,  19512,  21688,  23864,  26040,28216,   30392,  32568,  34744,
        2156,   4396,   6636,   8876,   11116,  13356,  15596,  17836,  20076,  22316,  24556,  26796,29036,   31276,  33516,  35756
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_8x8x8(void) {
    size_t m, k, n;
    m = n = k = 8;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        1792,   3584,   5376,   7168,   8960,   10752,  12544,  14336,
        1844,   3700,   5556,   7412,   9268,   11124,  12980,  14836,
        1896,   3816,   5736,   7656,   9576,   11496,  13416,  15336,
        1948,   3932,   5916,   7900,   9884,   11868,  13852,  15836,
        2000,   4048,   6096,   8144,   10192,  12240,  14288,  16336,
        2052,   4164,   6276,   8388,   10500,  12612,  14724,  16836,
        2104,   4280,   6456,   8632,   10808,  12984,  15160,  17336,
        2156,   4396,   6636,   8876,   11116,  13356,  15596,  17836,
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_16x8x16(void) {
    size_t m, k, n;
    m = n = 16;
    k = 8;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        3584,   7168,   10752,  14336,  17920,  21504,  25088,  28672,  32256,  35840,  39424,  43008, 46592,  50176,  53760,  57344,  
        3636,   7284,   10932,  14580,  18228,  21876,  25524,  29172,  32820,  36468,  40116,  43764, 47412,  51060,  54708,  58356,  
        3688,   7400,   11112,  14824,  18536,  22248,  25960,  29672,  33384,  37096,  40808,  44520, 48232,  51944,  55656,  59368,  
        3740,   7516,   11292,  15068,  18844,  22620,  26396,  30172,  33948,  37724,  41500,  45276, 49052,  52828,  56604,  60380,  
        3792,   7632,   11472,  15312,  19152,  22992,  26832,  30672,  34512,  38352,  42192,  46032, 49872,  53712,  57552,  61392,  
        3844,   7748,   11652,  15556,  19460,  23364,  27268,  31172,  35076,  38980,  42884,  46788, 50692,  54596,  58500,  62404,  
        3896,   7864,   11832,  15800,  19768,  23736,  27704,  31672,  35640,  39608,  43576,  47544, 51512,  55480,  59448,  63416,  
        3948,   7980,   12012,  16044,  20076,  24108,  28140,  32172,  36204,  40236,  44268,  48300, 52332,  56364,  60396,  64428,  
        4000,   8096,   12192,  16288,  20384,  24480,  28576,  32672,  36768,  40864,  44960,  49056, 53152,  57248,  61344,  65440,  
        4052,   8212,   12372,  16532,  20692,  24852,  29012,  33172,  37332,  41492,  45652,  49812, 53972,  58132,  62292,  66452,  
        4104,   8328,   12552,  16776,  21000,  25224,  29448,  33672,  37896,  42120,  46344,  50568, 54792,  59016,  63240,  67464,  
        4156,   8444,   12732,  17020,  21308,  25596,  29884,  34172,  38460,  42748,  47036,  51324, 55612,  59900,  64188,  68476,  
        4208,   8560,   12912,  17264,  21616,  25968,  30320,  34672,  39024,  43376,  47728,  52080, 56432,  60784,  65136,  69488,  
        4260,   8676,   13092,  17508,  21924,  26340,  30756,  35172,  39588,  44004,  48420,  52836, 57252,  61668,  66084,  70500,  
        4312,   8792,   13272,  17752,  22232,  26712,  31192,  35672,  40152,  44632,  49112,  53592, 58072,  62552,  67032,  71512,  
        4364,   8908,   13452,  17996,  22540,  27084,  31628,  36172,  40716,  45260,  49804,  54348, 58892,  63436,  67980,  72524,
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_16x16x8(void) {
    size_t m, k, n;
    m = k = 16;
    n = 8;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        25600,  56320,  87040,  117760, 148480, 179200, 209920, 240640, 
        25768,  56744,  87720,  118696, 149672, 180648, 211624, 242600, 
        25936,  57168,  88400,  119632, 150864, 182096, 213328, 244560, 
        26104,  57592,  89080,  120568, 152056, 183544, 215032, 246520, 
        26272,  58016,  89760,  121504, 153248, 184992, 216736, 248480, 
        26440,  58440,  90440,  122440, 154440, 186440, 218440, 250440, 
        26608,  58864,  91120,  123376, 155632, 187888, 220144, 252400, 
        26776,  59288,  91800,  124312, 156824, 189336, 221848, 254360, 
        26944,  59712,  92480,  125248, 158016, 190784, 223552, 256320, 
        27112,  60136,  93160,  126184, 159208, 192232, 225256, 258280, 
        27280,  60560,  93840,  127120, 160400, 193680, 226960, 260240, 
        27448,  60984,  94520,  128056, 161592, 195128, 228664, 262200, 
        27616,  61408,  95200,  128992, 162784, 196576, 230368, 264160, 
        27784,  61832,  95880,  129928, 163976, 198024, 232072, 266120, 
        27952,  62256,  96560,  130864, 165168, 199472, 233776, 268080, 
        28120,  62680,  97240,  131800, 166360, 200920, 235480, 270040
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_8x16x16(void) {
    size_t m, k, n;
    m = 8;
    k = n = 16;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        12800,  28160,  43520,  58880,  74240,  89600,  104960, 120320, 135680, 151040, 166400, 181760, 197120, 212480, 227840, 243200, 
        12968,  28584,  44200,  59816,  75432,  91048,  106664, 122280, 137896, 153512, 169128, 184744, 200360, 215976, 231592, 247208, 
        13136,  29008,  44880,  60752,  76624,  92496,  108368, 124240, 140112, 155984, 171856, 187728, 203600, 219472, 235344, 251216, 
        13304,  29432,  45560,  61688,  77816,  93944,  110072, 126200, 142328, 158456, 174584, 190712, 206840, 222968, 239096, 255224, 
        13472,  29856,  46240,  62624,  79008,  95392,  111776, 128160, 144544, 160928, 177312, 193696, 210080, 226464, 242848, 259232, 
        13640,  30280,  46920,  63560,  80200,  96840,  113480, 130120, 146760, 163400, 180040, 196680, 213320, 229960, 246600, 263240, 
        13808,  30704,  47600,  64496,  81392,  98288,  115184, 132080, 148976, 165872, 182768, 199664, 216560, 233456, 250352, 267248, 
        13976,  31128,  48280,  65432,  82584,  99736,  116888, 134040, 151192, 168344, 185496, 202648, 219800, 236952, 254104, 271256,
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_16x16x16(void) {
    size_t m, k, n;
    m = k = n = 16;

    m = align_up(m, pad(float));
    n = align_up(n, pad(float));
    k = align_up(k, pad(float));

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotam32(0.f, 1.f, a, k, m);
    iotam32(3.f, 1.f, b, n, k);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        25600,  56320,  87040,  117760, 148480, 179200, 209920, 240640, 271360, 302080, 332800, 363520, 394240, 424960, 455680, 486400, 
        25768,  56744,  87720,  118696, 149672, 180648, 211624, 242600, 273576, 304552, 335528, 366504, 397480, 428456, 459432, 490408, 
        25936,  57168,  88400,  119632, 150864, 182096, 213328, 244560, 275792, 307024, 338256, 369488, 400720, 431952, 463184, 494416, 
        26104,  57592,  89080,  120568, 152056, 183544, 215032, 246520, 278008, 309496, 340984, 372472, 403960, 435448, 466936, 498424, 
        26272,  58016,  89760,  121504, 153248, 184992, 216736, 248480, 280224, 311968, 343712, 375456, 407200, 438944, 470688, 502432, 
        26440,  58440,  90440,  122440, 154440, 186440, 218440, 250440, 282440, 314440, 346440, 378440, 410440, 442440, 474440, 506440, 
        26608,  58864,  91120,  123376, 155632, 187888, 220144, 252400, 284656, 316912, 349168, 381424, 413680, 445936, 478192, 510448, 
        26776,  59288,  91800,  124312, 156824, 189336, 221848, 254360, 286872, 319384, 351896, 384408, 416920, 449432, 481944, 514456, 
        26944,  59712,  92480,  125248, 158016, 190784, 223552, 256320, 289088, 321856, 354624, 387392, 420160, 452928, 485696, 518464, 
        27112,  60136,  93160,  126184, 159208, 192232, 225256, 258280, 291304, 324328, 357352, 390376, 423400, 456424, 489448, 522472, 
        27280,  60560,  93840,  127120, 160400, 193680, 226960, 260240, 293520, 326800, 360080, 393360, 426640, 459920, 493200, 526480, 
        27448,  60984,  94520,  128056, 161592, 195128, 228664, 262200, 295736, 329272, 362808, 396344, 429880, 463416, 496952, 530488, 
        27616,  61408,  95200,  128992, 162784, 196576, 230368, 264160, 297952, 331744, 365536, 399328, 433120, 466912, 500704, 534496, 
        27784,  61832,  95880,  129928, 163976, 198024, 232072, 266120, 300168, 334216, 368264, 402312, 436360, 470408, 504456, 538504, 
        27952,  62256,  96560,  130864, 165168, 199472, 233776, 268080, 302384, 336688, 370992, 405296, 439600, 473904, 508208, 542512, 
        28120,  62680,  97240,  131800, 166360, 200920, 235480, 270040, 304600, 339160, 373720, 408280, 442840, 477400, 511960, 546520,
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
test_3x3x3(void) {
    size_t m, k, n;
    m = n = k = 3;

    m = align_up(m, 8);
    n = align_up(n, 8);
    k = align_up(k, 8);

    float *a = calloc(m * k, sizeof (float));
    float *b = calloc(k * n, sizeof (float));
    float *c = calloc(m * n, sizeof (float));

    iotaoffm32(0.f, 1.f, a, k, m, 0, 0, 3, 3);
    iotaoffm32(3.f, 1.f, b, n, k, 0, 0, 3, 3);

    gemm32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        42,     69,     96,     0,      0,      0,      0,      0,
        54,     90,     126,    0,      0,      0,      0,      0,
        66,     111,    156,    0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
    }, e[sizeof (et) / sizeof (float)];
    chordm32(e, et, n, m);
    return eqm32(c, e, n, m) == 0;
}

int
main() {
    struct Tst {
        int (*fn)(void);
        const char *wh;
    } tests[] = {
        TEST(test_16x8x8),
        TEST(test_8x16x8),
        TEST(test_8x8x16),
        TEST(test_16x16x8),
        TEST(test_16x8x16),
        TEST(test_8x16x16),
        TEST(test_16x16x16),
        TEST(test_8x8x8),
        TEST(test_3x3x3),
        TEST(NULL),
    };
    for (struct Tst *test = tests; test->fn; test++) {
        int res = test->fn();
        printf("[%s]: %s\n", res ? "OK" : "FAIL", test->wh);
    }
}
