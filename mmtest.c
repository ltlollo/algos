// This is free and unencumbered software released into the public domain.
// For more information, see LICENSE

#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "mm.h"

#define TEST(x) {x, ""#x }
#define L3 (2048 * 1024)
#define L2 ( 256 * 1024)

static _Alignas(32) float A[L2 / sizeof (float)];
static _Alignas(32) float B[L3 / sizeof (float)];

int
test_dgemmf32_8x16x8(void) {
    size_t m, k, n;
    m = n = 8;
    k = 16;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        12800,  28160,  43520,  58880,  74240,  89600,  104960, 120320,
        12968,  28584,  44200,  59816,  75432,  91048,  106664, 122280,
        13136,  29008,  44880,  60752,  76624,  92496,  108368, 124240,
        13304,  29432,  45560,  61688,  77816,  93944,  110072, 126200,
        13472,  29856,  46240,  62624,  79008,  95392,  111776, 128160,
        13640,  30280,  46920,  63560,  80200,  96840,  113480, 130120,
        13808,  30704,  47600,  64496,  81392,  98288,  115184, 132080,
        13976,  31128,  48280,  65432,  82584,  99736,  116888, 134040,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_16x8x8(void) {
    size_t m, k, n;
    m = 16;
    n = k = 8;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        3584,   7168,   10752,  14336,  17920,  21504,  25088,  28672,
        3636,   7284,   10932,  14580,  18228,  21876,  25524,  29172,
        3688,   7400,   11112,  14824,  18536,  22248,  25960,  29672,
        3740,   7516,   11292,  15068,  18844,  22620,  26396,  30172,
        3792,   7632,   11472,  15312,  19152,  22992,  26832,  30672,
        3844,   7748,   11652,  15556,  19460,  23364,  27268,  31172,
        3896,   7864,   11832,  15800,  19768,  23736,  27704,  31672,
        3948,   7980,   12012,  16044,  20076,  24108,  28140,  32172,
        4000,   8096,   12192,  16288,  20384,  24480,  28576,  32672,
        4052,   8212,   12372,  16532,  20692,  24852,  29012,  33172,
        4104,   8328,   12552,  16776,  21000,  25224,  29448,  33672,
        4156,   8444,   12732,  17020,  21308,  25596,  29884,  34172,
        4208,   8560,   12912,  17264,  21616,  25968,  30320,  34672,
        4260,   8676,   13092,  17508,  21924,  26340,  30756,  35172,
        4312,   8792,   13272,  17752,  22232,  26712,  31192,  35672,
        4364,   8908,   13452,  17996,  22540,  27084,  31628,  36172,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_8x8x16(void) {
    size_t m, k, n;
    n = 16;
    m = k = 8;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        1792,   3584,   5376,   7168,   8960,   10752,  12544,  14336,  16128,  17920,  19712,  21504,23296,   25088,  26880,  28672,
        1844,   3700,   5556,   7412,   9268,   11124,  12980,  14836,  16692,  18548,  20404,  22260,24116,   25972,  27828,  29684,
        1896,   3816,   5736,   7656,   9576,   11496,  13416,  15336,  17256,  19176,  21096,  23016,24936,   26856,  28776,  30696,
        1948,   3932,   5916,   7900,   9884,   11868,  13852,  15836,  17820,  19804,  21788,  23772,25756,   27740,  29724,  31708,
        2000,   4048,   6096,   8144,   10192,  12240,  14288,  16336,  18384,  20432,  22480,  24528,26576,   28624,  30672,  32720,
        2052,   4164,   6276,   8388,   10500,  12612,  14724,  16836,  18948,  21060,  23172,  25284,27396,   29508,  31620,  33732,
        2104,   4280,   6456,   8632,   10808,  12984,  15160,  17336,  19512,  21688,  23864,  26040,28216,   30392,  32568,  34744,
        2156,   4396,   6636,   8876,   11116,  13356,  15596,  17836,  20076,  22316,  24556,  26796,29036,   31276,  33516,  35756
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_8x8x8(void) {
    size_t m, k, n;
    m = n = k = 8;


    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        1792,   3584,   5376,   7168,   8960,   10752,  12544,  14336,
        1844,   3700,   5556,   7412,   9268,   11124,  12980,  14836,
        1896,   3816,   5736,   7656,   9576,   11496,  13416,  15336,
        1948,   3932,   5916,   7900,   9884,   11868,  13852,  15836,
        2000,   4048,   6096,   8144,   10192,  12240,  14288,  16336,
        2052,   4164,   6276,   8388,   10500,  12612,  14724,  16836,
        2104,   4280,   6456,   8632,   10808,  12984,  15160,  17336,
        2156,   4396,   6636,   8876,   11116,  13356,  15596,  17836,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_16x8x16(void) {
    size_t m, k, n;
    m = n = 16;
    k = 8;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        3584,   7168,   10752,  14336,  17920,  21504,  25088,  28672,  32256,  35840,  39424,  43008, 46592,  50176,  53760,  57344,
        3636,   7284,   10932,  14580,  18228,  21876,  25524,  29172,  32820,  36468,  40116,  43764, 47412,  51060,  54708,  58356,
        3688,   7400,   11112,  14824,  18536,  22248,  25960,  29672,  33384,  37096,  40808,  44520, 48232,  51944,  55656,  59368,
        3740,   7516,   11292,  15068,  18844,  22620,  26396,  30172,  33948,  37724,  41500,  45276, 49052,  52828,  56604,  60380,
        3792,   7632,   11472,  15312,  19152,  22992,  26832,  30672,  34512,  38352,  42192,  46032, 49872,  53712,  57552,  61392,
        3844,   7748,   11652,  15556,  19460,  23364,  27268,  31172,  35076,  38980,  42884,  46788, 50692,  54596,  58500,  62404,
        3896,   7864,   11832,  15800,  19768,  23736,  27704,  31672,  35640,  39608,  43576,  47544, 51512,  55480,  59448,  63416,
        3948,   7980,   12012,  16044,  20076,  24108,  28140,  32172,  36204,  40236,  44268,  48300, 52332,  56364,  60396,  64428,
        4000,   8096,   12192,  16288,  20384,  24480,  28576,  32672,  36768,  40864,  44960,  49056, 53152,  57248,  61344,  65440,
        4052,   8212,   12372,  16532,  20692,  24852,  29012,  33172,  37332,  41492,  45652,  49812, 53972,  58132,  62292,  66452,
        4104,   8328,   12552,  16776,  21000,  25224,  29448,  33672,  37896,  42120,  46344,  50568, 54792,  59016,  63240,  67464,
        4156,   8444,   12732,  17020,  21308,  25596,  29884,  34172,  38460,  42748,  47036,  51324, 55612,  59900,  64188,  68476,
        4208,   8560,   12912,  17264,  21616,  25968,  30320,  34672,  39024,  43376,  47728,  52080, 56432,  60784,  65136,  69488,
        4260,   8676,   13092,  17508,  21924,  26340,  30756,  35172,  39588,  44004,  48420,  52836, 57252,  61668,  66084,  70500,
        4312,   8792,   13272,  17752,  22232,  26712,  31192,  35672,  40152,  44632,  49112,  53592, 58072,  62552,  67032,  71512,
        4364,   8908,   13452,  17996,  22540,  27084,  31628,  36172,  40716,  45260,  49804,  54348, 58892,  63436,  67980,  72524,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_16x16x8(void) {
    size_t m, k, n;
    m = k = 16;
    n = 8;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        25600,  56320,  87040,  117760, 148480, 179200, 209920, 240640,
        25768,  56744,  87720,  118696, 149672, 180648, 211624, 242600,
        25936,  57168,  88400,  119632, 150864, 182096, 213328, 244560,
        26104,  57592,  89080,  120568, 152056, 183544, 215032, 246520,
        26272,  58016,  89760,  121504, 153248, 184992, 216736, 248480,
        26440,  58440,  90440,  122440, 154440, 186440, 218440, 250440,
        26608,  58864,  91120,  123376, 155632, 187888, 220144, 252400,
        26776,  59288,  91800,  124312, 156824, 189336, 221848, 254360,
        26944,  59712,  92480,  125248, 158016, 190784, 223552, 256320,
        27112,  60136,  93160,  126184, 159208, 192232, 225256, 258280,
        27280,  60560,  93840,  127120, 160400, 193680, 226960, 260240,
        27448,  60984,  94520,  128056, 161592, 195128, 228664, 262200,
        27616,  61408,  95200,  128992, 162784, 196576, 230368, 264160,
        27784,  61832,  95880,  129928, 163976, 198024, 232072, 266120,
        27952,  62256,  96560,  130864, 165168, 199472, 233776, 268080,
        28120,  62680,  97240,  131800, 166360, 200920, 235480, 270040
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_8x16x16(void) {
    size_t m, k, n;
    m = 8;
    k = n = 16;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        12800,  28160,  43520,  58880,  74240,  89600,  104960, 120320, 135680, 151040, 166400, 181760, 197120, 212480, 227840, 243200,
        12968,  28584,  44200,  59816,  75432,  91048,  106664, 122280, 137896, 153512, 169128, 184744, 200360, 215976, 231592, 247208,
        13136,  29008,  44880,  60752,  76624,  92496,  108368, 124240, 140112, 155984, 171856, 187728, 203600, 219472, 235344, 251216,
        13304,  29432,  45560,  61688,  77816,  93944,  110072, 126200, 142328, 158456, 174584, 190712, 206840, 222968, 239096, 255224,
        13472,  29856,  46240,  62624,  79008,  95392,  111776, 128160, 144544, 160928, 177312, 193696, 210080, 226464, 242848, 259232,
        13640,  30280,  46920,  63560,  80200,  96840,  113480, 130120, 146760, 163400, 180040, 196680, 213320, 229960, 246600, 263240,
        13808,  30704,  47600,  64496,  81392,  98288,  115184, 132080, 148976, 165872, 182768, 199664, 216560, 233456, 250352, 267248,
        13976,  31128,  48280,  65432,  82584,  99736,  116888, 134040, 151192, 168344, 185496, 202648, 219800, 236952, 254104, 271256,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_16x16x16(void) {
    size_t m, k, n;
    m = k = n = 16;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotamf32(0.f, 1.f, a, m, k);
    iotamf32(3.f, 1.f, b, k, n);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        25600,  56320,  87040,  117760, 148480, 179200, 209920, 240640, 271360, 302080, 332800, 363520, 394240, 424960, 455680, 486400,
        25768,  56744,  87720,  118696, 149672, 180648, 211624, 242600, 273576, 304552, 335528, 366504, 397480, 428456, 459432, 490408,
        25936,  57168,  88400,  119632, 150864, 182096, 213328, 244560, 275792, 307024, 338256, 369488, 400720, 431952, 463184, 494416,
        26104,  57592,  89080,  120568, 152056, 183544, 215032, 246520, 278008, 309496, 340984, 372472, 403960, 435448, 466936, 498424,
        26272,  58016,  89760,  121504, 153248, 184992, 216736, 248480, 280224, 311968, 343712, 375456, 407200, 438944, 470688, 502432,
        26440,  58440,  90440,  122440, 154440, 186440, 218440, 250440, 282440, 314440, 346440, 378440, 410440, 442440, 474440, 506440,
        26608,  58864,  91120,  123376, 155632, 187888, 220144, 252400, 284656, 316912, 349168, 381424, 413680, 445936, 478192, 510448,
        26776,  59288,  91800,  124312, 156824, 189336, 221848, 254360, 286872, 319384, 351896, 384408, 416920, 449432, 481944, 514456,
        26944,  59712,  92480,  125248, 158016, 190784, 223552, 256320, 289088, 321856, 354624, 387392, 420160, 452928, 485696, 518464,
        27112,  60136,  93160,  126184, 159208, 192232, 225256, 258280, 291304, 324328, 357352, 390376, 423400, 456424, 489448, 522472,
        27280,  60560,  93840,  127120, 160400, 193680, 226960, 260240, 293520, 326800, 360080, 393360, 426640, 459920, 493200, 526480,
        27448,  60984,  94520,  128056, 161592, 195128, 228664, 262200, 295736, 329272, 362808, 396344, 429880, 463416, 496952, 530488,
        27616,  61408,  95200,  128992, 162784, 196576, 230368, 264160, 297952, 331744, 365536, 399328, 433120, 466912, 500704, 534496,
        27784,  61832,  95880,  129928, 163976, 198024, 232072, 266120, 300168, 334216, 368264, 402312, 436360, 470408, 504456, 538504,
        27952,  62256,  96560,  130864, 165168, 199472, 233776, 268080, 302384, 336688, 370992, 405296, 439600, 473904, 508208, 542512,
        28120,  62680,  97240,  131800, 166360, 200920, 235480, 270040, 304600, 339160, 373720, 408280, 442840, 477400, 511960, 546520,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemmf32_3x3x3(void) {
    size_t m, k, n;
    m = n = k = 3;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);

    iotaoffmf32(0.f, 1.f, a, m, k, 0, 0, 3, 3);
    iotaoffmf32(3.f, 1.f, b, k, n, 0, 0, 3, 3);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);

    static float et[] = {
        42,     69,     96,     0,      0,      0,      0,      0,
        54,     90,     126,    0,      0,      0,      0,      0,
        66,     111,    156,    0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
        0,      0,      0,      0,      0,      0,      0,      0,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);
    return eqmf32(c, e, m, n) == 0;
}

int
test_Tmf32_16x24(void) {
    size_t m = 16;
    size_t n = 24;

    float *a = allocmf32(m, n);
    float *b = allocmf32(n, m);

    static float et[] = {
        0.00,   1.00,   2.00,   3.00,   4.00,   5.00,   6.00,   7.00,   8.00,   9.00,   10.00,  11.00,  12.00,  13.00,  14.00,  15.00,  16.00,  17.00,  18.00,  19.00,  20.00,  21.00,  22.00,  23.00,
        24.00,  25.00,  26.00,  27.00,  28.00,  29.00,  30.00,  31.00,  32.00,  33.00,  34.00,  35.00,  36.00,  37.00,  38.00,  39.00,  40.00,  41.00,  42.00,  43.00,  44.00,  45.00,  46.00,  47.00,
        48.00,  49.00,  50.00,  51.00,  52.00,  53.00,  54.00,  55.00,  56.00,  57.00,  58.00,  59.00,  60.00,  61.00,  62.00,  63.00,  64.00,  65.00,  66.00,  67.00,  68.00,  69.00,  70.00,  71.00,
        72.00,  73.00,  74.00,  75.00,  76.00,  77.00,  78.00,  79.00,  80.00,  81.00,  82.00,  83.00,  84.00,  85.00,  86.00,  87.00,  88.00,  89.00,  90.00,  91.00,  92.00,  93.00,  94.00,  95.00,
        96.00,  97.00,  98.00,  99.00,  100.00, 101.00, 102.00, 103.00, 104.00, 105.00, 106.00, 107.00, 108.00, 109.00, 110.00, 111.00, 112.00, 113.00, 114.00, 115.00, 116.00, 117.00, 118.00, 119.00,
        120.00, 121.00, 122.00, 123.00, 124.00, 125.00, 126.00, 127.00, 128.00, 129.00, 130.00, 131.00, 132.00, 133.00, 134.00, 135.00, 136.00, 137.00, 138.00, 139.00, 140.00, 141.00, 142.00, 143.00,
        144.00, 145.00, 146.00, 147.00, 148.00, 149.00, 150.00, 151.00, 152.00, 153.00, 154.00, 155.00, 156.00, 157.00, 158.00, 159.00, 160.00, 161.00, 162.00, 163.00, 164.00, 165.00, 166.00, 167.00,
        168.00, 169.00, 170.00, 171.00, 172.00, 173.00, 174.00, 175.00, 176.00, 177.00, 178.00, 179.00, 180.00, 181.00, 182.00, 183.00, 184.00, 185.00, 186.00, 187.00, 188.00, 189.00, 190.00, 191.00,
        192.00, 193.00, 194.00, 195.00, 196.00, 197.00, 198.00, 199.00, 200.00, 201.00, 202.00, 203.00, 204.00, 205.00, 206.00, 207.00, 208.00, 209.00, 210.00, 211.00, 212.00, 213.00, 214.00, 215.00,
        216.00, 217.00, 218.00, 219.00, 220.00, 221.00, 222.00, 223.00, 224.00, 225.00, 226.00, 227.00, 228.00, 229.00, 230.00, 231.00, 232.00, 233.00, 234.00, 235.00, 236.00, 237.00, 238.00, 239.00,
        240.00, 241.00, 242.00, 243.00, 244.00, 245.00, 246.00, 247.00, 248.00, 249.00, 250.00, 251.00, 252.00, 253.00, 254.00, 255.00, 256.00, 257.00, 258.00, 259.00, 260.00, 261.00, 262.00, 263.00,
        264.00, 265.00, 266.00, 267.00, 268.00, 269.00, 270.00, 271.00, 272.00, 273.00, 274.00, 275.00, 276.00, 277.00, 278.00, 279.00, 280.00, 281.00, 282.00, 283.00, 284.00, 285.00, 286.00, 287.00,
        288.00, 289.00, 290.00, 291.00, 292.00, 293.00, 294.00, 295.00, 296.00, 297.00, 298.00, 299.00, 300.00, 301.00, 302.00, 303.00, 304.00, 305.00, 306.00, 307.00, 308.00, 309.00, 310.00, 311.00,
        312.00, 313.00, 314.00, 315.00, 316.00, 317.00, 318.00, 319.00, 320.00, 321.00, 322.00, 323.00, 324.00, 325.00, 326.00, 327.00, 328.00, 329.00, 330.00, 331.00, 332.00, 333.00, 334.00, 335.00,
        336.00, 337.00, 338.00, 339.00, 340.00, 341.00, 342.00, 343.00, 344.00, 345.00, 346.00, 347.00, 348.00, 349.00, 350.00, 351.00, 352.00, 353.00, 354.00, 355.00, 356.00, 357.00, 358.00, 359.00,
        360.00, 361.00, 362.00, 363.00, 364.00, 365.00, 366.00, 367.00, 368.00, 369.00, 370.00, 371.00, 372.00, 373.00, 374.00, 375.00, 376.00, 377.00, 378.00, 379.00, 380.00, 381.00, 382.00, 383.00,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);

    iotamf32(0.f, 1.f, a, n, m);

    Tmf32(a, b, n, m);

    return eqmf32(b, e, m, n) == 0;
}

int
test_Tmf32_24x16(void) {
    size_t m = 24;
    size_t n = 16;

    float *a = allocmf32(m, n);
    float *b = allocmf32(n, m);

    static float et[] = {
        0.00,   1.00,   2.00,   3.00,   4.00,   5.00,   6.00,   7.00,   8.00,   9.00,   10.00,  11.00,  12.00,  13.00,  14.00,  15.00,
        16.00,  17.00,  18.00,  19.00,  20.00,  21.00,  22.00,  23.00,  24.00,  25.00,  26.00,  27.00,  28.00,  29.00,  30.00,  31.00,
        32.00,  33.00,  34.00,  35.00,  36.00,  37.00,  38.00,  39.00,  40.00,  41.00,  42.00,  43.00,  44.00,  45.00,  46.00,  47.00,
        48.00,  49.00,  50.00,  51.00,  52.00,  53.00,  54.00,  55.00,  56.00,  57.00,  58.00,  59.00,  60.00,  61.00,  62.00,  63.00,
        64.00,  65.00,  66.00,  67.00,  68.00,  69.00,  70.00,  71.00,  72.00,  73.00,  74.00,  75.00,  76.00,  77.00,  78.00,  79.00,
        80.00,  81.00,  82.00,  83.00,  84.00,  85.00,  86.00,  87.00,  88.00,  89.00,  90.00,  91.00,  92.00,  93.00,  94.00,  95.00,
        96.00,  97.00,  98.00,  99.00,  100.00, 101.00, 102.00, 103.00, 104.00, 105.00, 106.00, 107.00, 108.00, 109.00, 110.00, 111.00,
        112.00, 113.00, 114.00, 115.00, 116.00, 117.00, 118.00, 119.00, 120.00, 121.00, 122.00, 123.00, 124.00, 125.00, 126.00, 127.00,
        128.00, 129.00, 130.00, 131.00, 132.00, 133.00, 134.00, 135.00, 136.00, 137.00, 138.00, 139.00, 140.00, 141.00, 142.00, 143.00,
        144.00, 145.00, 146.00, 147.00, 148.00, 149.00, 150.00, 151.00, 152.00, 153.00, 154.00, 155.00, 156.00, 157.00, 158.00, 159.00,
        160.00, 161.00, 162.00, 163.00, 164.00, 165.00, 166.00, 167.00, 168.00, 169.00, 170.00, 171.00, 172.00, 173.00, 174.00, 175.00,
        176.00, 177.00, 178.00, 179.00, 180.00, 181.00, 182.00, 183.00, 184.00, 185.00, 186.00, 187.00, 188.00, 189.00, 190.00, 191.00,
        192.00, 193.00, 194.00, 195.00, 196.00, 197.00, 198.00, 199.00, 200.00, 201.00, 202.00, 203.00, 204.00, 205.00, 206.00, 207.00,
        208.00, 209.00, 210.00, 211.00, 212.00, 213.00, 214.00, 215.00, 216.00, 217.00, 218.00, 219.00, 220.00, 221.00, 222.00, 223.00,
        224.00, 225.00, 226.00, 227.00, 228.00, 229.00, 230.00, 231.00, 232.00, 233.00, 234.00, 235.00, 236.00, 237.00, 238.00, 239.00,
        240.00, 241.00, 242.00, 243.00, 244.00, 245.00, 246.00, 247.00, 248.00, 249.00, 250.00, 251.00, 252.00, 253.00, 254.00, 255.00,
        256.00, 257.00, 258.00, 259.00, 260.00, 261.00, 262.00, 263.00, 264.00, 265.00, 266.00, 267.00, 268.00, 269.00, 270.00, 271.00,
        272.00, 273.00, 274.00, 275.00, 276.00, 277.00, 278.00, 279.00, 280.00, 281.00, 282.00, 283.00, 284.00, 285.00, 286.00, 287.00,
        288.00, 289.00, 290.00, 291.00, 292.00, 293.00, 294.00, 295.00, 296.00, 297.00, 298.00, 299.00, 300.00, 301.00, 302.00, 303.00,
        304.00, 305.00, 306.00, 307.00, 308.00, 309.00, 310.00, 311.00, 312.00, 313.00, 314.00, 315.00, 316.00, 317.00, 318.00, 319.00,
        320.00, 321.00, 322.00, 323.00, 324.00, 325.00, 326.00, 327.00, 328.00, 329.00, 330.00, 331.00, 332.00, 333.00, 334.00, 335.00,
        336.00, 337.00, 338.00, 339.00, 340.00, 341.00, 342.00, 343.00, 344.00, 345.00, 346.00, 347.00, 348.00, 349.00, 350.00, 351.00,
        352.00, 353.00, 354.00, 355.00, 356.00, 357.00, 358.00, 359.00, 360.00, 361.00, 362.00, 363.00, 364.00, 365.00, 366.00, 367.00,
        368.00, 369.00, 370.00, 371.00, 372.00, 373.00, 374.00, 375.00, 376.00, 377.00, 378.00, 379.00, 380.00, 381.00, 382.00, 383.00,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);

    iotamf32(0.f, 1.f, a, n, m);

    Tmf32(a, b, n, m);

    return eqmf32(b, e, m, n) == 0;
}

int
test_Tmf64_24x16(void) {
    size_t m = 24;
    size_t n = 16;

    double *a = allocmf64(m, n);
    double *b = allocmf64(n, m);

    static double et[] = {
        0.00,   1.00,   2.00,   3.00,   4.00,   5.00,   6.00,   7.00,   8.00,   9.00,   10.00,  11.00,  12.00,  13.00,  14.00,  15.00,
        16.00,  17.00,  18.00,  19.00,  20.00,  21.00,  22.00,  23.00,  24.00,  25.00,  26.00,  27.00,  28.00,  29.00,  30.00,  31.00,
        32.00,  33.00,  34.00,  35.00,  36.00,  37.00,  38.00,  39.00,  40.00,  41.00,  42.00,  43.00,  44.00,  45.00,  46.00,  47.00,
        48.00,  49.00,  50.00,  51.00,  52.00,  53.00,  54.00,  55.00,  56.00,  57.00,  58.00,  59.00,  60.00,  61.00,  62.00,  63.00,
        64.00,  65.00,  66.00,  67.00,  68.00,  69.00,  70.00,  71.00,  72.00,  73.00,  74.00,  75.00,  76.00,  77.00,  78.00,  79.00,
        80.00,  81.00,  82.00,  83.00,  84.00,  85.00,  86.00,  87.00,  88.00,  89.00,  90.00,  91.00,  92.00,  93.00,  94.00,  95.00,
        96.00,  97.00,  98.00,  99.00,  100.00, 101.00, 102.00, 103.00, 104.00, 105.00, 106.00, 107.00, 108.00, 109.00, 110.00, 111.00,
        112.00, 113.00, 114.00, 115.00, 116.00, 117.00, 118.00, 119.00, 120.00, 121.00, 122.00, 123.00, 124.00, 125.00, 126.00, 127.00,
        128.00, 129.00, 130.00, 131.00, 132.00, 133.00, 134.00, 135.00, 136.00, 137.00, 138.00, 139.00, 140.00, 141.00, 142.00, 143.00,
        144.00, 145.00, 146.00, 147.00, 148.00, 149.00, 150.00, 151.00, 152.00, 153.00, 154.00, 155.00, 156.00, 157.00, 158.00, 159.00,
        160.00, 161.00, 162.00, 163.00, 164.00, 165.00, 166.00, 167.00, 168.00, 169.00, 170.00, 171.00, 172.00, 173.00, 174.00, 175.00,
        176.00, 177.00, 178.00, 179.00, 180.00, 181.00, 182.00, 183.00, 184.00, 185.00, 186.00, 187.00, 188.00, 189.00, 190.00, 191.00,
        192.00, 193.00, 194.00, 195.00, 196.00, 197.00, 198.00, 199.00, 200.00, 201.00, 202.00, 203.00, 204.00, 205.00, 206.00, 207.00,
        208.00, 209.00, 210.00, 211.00, 212.00, 213.00, 214.00, 215.00, 216.00, 217.00, 218.00, 219.00, 220.00, 221.00, 222.00, 223.00,
        224.00, 225.00, 226.00, 227.00, 228.00, 229.00, 230.00, 231.00, 232.00, 233.00, 234.00, 235.00, 236.00, 237.00, 238.00, 239.00,
        240.00, 241.00, 242.00, 243.00, 244.00, 245.00, 246.00, 247.00, 248.00, 249.00, 250.00, 251.00, 252.00, 253.00, 254.00, 255.00,
        256.00, 257.00, 258.00, 259.00, 260.00, 261.00, 262.00, 263.00, 264.00, 265.00, 266.00, 267.00, 268.00, 269.00, 270.00, 271.00,
        272.00, 273.00, 274.00, 275.00, 276.00, 277.00, 278.00, 279.00, 280.00, 281.00, 282.00, 283.00, 284.00, 285.00, 286.00, 287.00,
        288.00, 289.00, 290.00, 291.00, 292.00, 293.00, 294.00, 295.00, 296.00, 297.00, 298.00, 299.00, 300.00, 301.00, 302.00, 303.00,
        304.00, 305.00, 306.00, 307.00, 308.00, 309.00, 310.00, 311.00, 312.00, 313.00, 314.00, 315.00, 316.00, 317.00, 318.00, 319.00,
        320.00, 321.00, 322.00, 323.00, 324.00, 325.00, 326.00, 327.00, 328.00, 329.00, 330.00, 331.00, 332.00, 333.00, 334.00, 335.00,
        336.00, 337.00, 338.00, 339.00, 340.00, 341.00, 342.00, 343.00, 344.00, 345.00, 346.00, 347.00, 348.00, 349.00, 350.00, 351.00,
        352.00, 353.00, 354.00, 355.00, 356.00, 357.00, 358.00, 359.00, 360.00, 361.00, 362.00, 363.00, 364.00, 365.00, 366.00, 367.00,
        368.00, 369.00, 370.00, 371.00, 372.00, 373.00, 374.00, 375.00, 376.00, 377.00, 378.00, 379.00, 380.00, 381.00, 382.00, 383.00,
    }, e[sizeof (et) / sizeof (double)];
    chordmf64(e, et, m, n);

    iotamf64(0.f, 1.f, a, n, m);

    Tmf64(a, b, n, m);

    return eqmf64(b, e, m, n) == 0;
}

int
test_mtdgemmf32_256x256(void) {
    size_t m, k, n;
    m = n = k = 256;

    float *a = allocmf32(m, k);
    float *b = allocmf32(k, n);
    float *c = allocmf32(m, n);
    float *d = allocmf32(m, n);

    iotamf32(0.f, 0.1f, a, k, m);
    iotamf32(3.f, 0.1f, b, n, k);

    dgemmf32(a, b, c, m, k, n, A, B, L2, L3);
    mtdgemmf32(a, b, d, m, k, n, L2, L3, 8);

    return eqmf32(c, d, m, n) == 0;
}

int
test_dgerf32_16x16(void) {
    size_t m, n;
    m = n = 16;

    float *a = allocvf32(m);
    float *b = allocvf32(n);
    float *c = allocmf32(m, n);

    static float et[] = {
        0.00,   0.00,   0.00,   0.00,   0.00,   0.00,   0.00,   0.00,   0.00,   0.00,   0.00,   0.00, 0.00,    0.00,   0.00,   0.00,
        3.00,   4.00,   5.00,   6.00,   7.00,   8.00,   9.00,   10.00,  11.00,  12.00,  13.00,  14.00,15.00,   16.00,  17.00,  18.00,
        6.00,   8.00,   10.00,  12.00,  14.00,  16.00,  18.00,  20.00,  22.00,  24.00,  26.00,  28.00,30.00,   32.00,  34.00,  36.00,
        9.00,   12.00,  15.00,  18.00,  21.00,  24.00,  27.00,  30.00,  33.00,  36.00,  39.00,  42.00,45.00,   48.00,  51.00,  54.00,
        12.00,  16.00,  20.00,  24.00,  28.00,  32.00,  36.00,  40.00,  44.00,  48.00,  52.00,  56.00,60.00,   64.00,  68.00,  72.00,
        15.00,  20.00,  25.00,  30.00,  35.00,  40.00,  45.00,  50.00,  55.00,  60.00,  65.00,  70.00,75.00,   80.00,  85.00,  90.00,
        18.00,  24.00,  30.00,  36.00,  42.00,  48.00,  54.00,  60.00,  66.00,  72.00,  78.00,  84.00,90.00,   96.00,  102.00, 108.00,
        21.00,  28.00,  35.00,  42.00,  49.00,  56.00,  63.00,  70.00,  77.00,  84.00,  91.00,  98.00,105.00,  112.00, 119.00, 126.00,
        24.00,  32.00,  40.00,  48.00,  56.00,  64.00,  72.00,  80.00,  88.00,  96.00,  104.00, 112.00,120.00, 128.00, 136.00, 144.00,
        27.00,  36.00,  45.00,  54.00,  63.00,  72.00,  81.00,  90.00,  99.00,  108.00, 117.00, 126.00,135.00, 144.00, 153.00, 162.00,
        30.00,  40.00,  50.00,  60.00,  70.00,  80.00,  90.00,  100.00, 110.00, 120.00, 130.00, 140.00,150.00, 160.00, 170.00, 180.00,
        33.00,  44.00,  55.00,  66.00,  77.00,  88.00,  99.00,  110.00, 121.00, 132.00, 143.00, 154.00,165.00, 176.00, 187.00, 198.00,
        36.00,  48.00,  60.00,  72.00,  84.00,  96.00,  108.00, 120.00, 132.00, 144.00, 156.00, 168.00,180.00, 192.00, 204.00, 216.00,
        39.00,  52.00,  65.00,  78.00,  91.00,  104.00, 117.00, 130.00, 143.00, 156.00, 169.00, 182.00,195.00, 208.00, 221.00, 234.00,
        42.00,  56.00,  70.00,  84.00,  98.00,  112.00, 126.00, 140.00, 154.00, 168.00, 182.00, 196.00,210.00, 224.00, 238.00, 252.00,
        45.00,  60.00,  75.00,  90.00,  105.00, 120.00, 135.00, 150.00, 165.00, 180.00, 195.00, 210.00,225.00, 240.00, 255.00, 270.00,
    }, e[sizeof (et) / sizeof (float)];
    chordmf32(e, et, m, n);

    iotavf32(0.f, 1.f, a, m);
    iotavf32(3.f, 1.f, b, n);

    dgerf32(a, b, c, m, n);

    return eqmf32(c, e, m, n) == 0;
}

int
test_dgemv_8x16(void) {
    size_t m, n;
    m = 8;
    n = 16;

    float *a = allocmf32(m, n);
    float *b = allocvf32(n);
    float *c = allocvf32(m);

    static float e[] = {
        12800.00,
        12968.00,
        13136.00,
        13304.00,
        13472.00,
        13640.00,
        13808.00,
        13976.00
    };

    iotamf32(0.f, 1.f, a, m, n);
    iotavf32(3.f, 1.f, b, n);

    dgemvf32(a, b, c, m, n);

    return eqvf32(c, e, m) == 0;
}

int
test_axpy_16(void) {
    size_t m;
    m = 16;

    float *a = allocvf32(m);
    float b = 3;
    float *c = allocvf32(m);

    static float e[] = {
        0,
        3,
        6,
        9,
        12,
        15,
        18,
        21,
        24,
        27,
        30,
        33,
        36,
        39,
        42,
        45, 
    };

    iotavf32(0.f, 1.f, a, m);

    axpyf32(a, b, c, m);

    return eqvf32(c, e, m) == 0;
}

int
main() {
    struct Tst {
        int (*fn)(void);
        const char *wh;
    } tests[] = {
        TEST(test_dgemmf32_16x8x8),
        TEST(test_dgemmf32_8x16x8),
        TEST(test_dgemmf32_8x8x16),
        TEST(test_dgemmf32_16x16x8),
        TEST(test_dgemmf32_16x8x16),
        TEST(test_dgemmf32_8x16x16),
        TEST(test_dgemmf32_16x16x16),
        TEST(test_dgemmf32_8x8x8),
        TEST(test_dgemmf32_3x3x3),
        TEST(test_Tmf32_16x24),
        TEST(test_Tmf32_24x16),
        TEST(test_Tmf64_24x16),
        TEST(test_mtdgemmf32_256x256),
        TEST(test_dgerf32_16x16),
        TEST(test_dgemv_8x16),
        TEST(test_axpy_16),
        TEST(NULL),
    };
    for (struct Tst *test = tests; test->fn; test++) {
        int res = test->fn();
        printf("[%s]: %s\n", res ? "OK" : "FAIL", test->wh);
    }
}
